---
name: figma-vars-json-gen
description: Regra para criar arquivos JSON atrav√©s de agente de IA
---

# Agente de IA para Cria√ß√£o de Design Tokens Figma

## Ativa√ß√£o
Este agente √© ativado quando o usu√°rio mencionar que deseja criar um arquivo JSON de variables/tokens para Figma (ou express√µes similares).

## Princ√≠pio Fundamental de Intera√ß√£o

**REGRA CR√çTICA**: A IA deve fazer **APENAS UMA PERGUNTA POR VEZ** e aguardar a resposta do usu√°rio antes de prosseguir.

**N√ÉO FAZER:**
‚ùå Fazer m√∫ltiplas perguntas em sequ√™ncia
‚ùå Assumir respostas ou usar valores padr√£o sem confirmar
‚ùå Pular etapas do fluxo

**FAZER:**
‚úÖ Fazer uma pergunta
‚úÖ Aguardar resposta do usu√°rio
‚úÖ Processar a resposta
‚úÖ Fazer a pr√≥xima pergunta

**Exemplo correto:**
```
ü§ñ Cole a URL da tabela com os design tokens:

[aguarda resposta]

üë§ https://coda.io/d/...

ü§ñ Processando tabela...
‚úÖ Nome da cole√ß√£o detectado: design-system
‚úÖ Modes detectados: Light, Dark, Value
‚úÖ Ser√£o criados 3 arquivos JSON: Light.json, Dark.json, Value.json
```

**Exemplo INCORRETO:**
```
‚ùå Qual o nome da cole√ß√£o? E o nome do mode? E a URL da tabela?
```

## Estrutura de Pastas
Todos os arquivos devem ser criados seguindo esta estrutura:
```
packages/
  ‚îî‚îÄ‚îÄ tokens/
      ‚îî‚îÄ‚îÄ src/
          ‚îî‚îÄ‚îÄ figma/
              ‚îî‚îÄ‚îÄ {nome-da-colecao}/
                  ‚îî‚îÄ‚îÄ {nome-do-mode}.json
```

Se a pasta `figma` n√£o existir, ela deve ser criada automaticamente.

## Fluxo de Intera√ß√£o

### 1. Solicitar URL da Tabela
- Pedir a URL onde est√° a tabela de design tokens
- **Estrutura da tabela**:
  - A primeira coluna sempre ser√° `Token Name` (ou `Token name`)
  - As colunas seguintes s√£o os nomes dos modes (ex: `Value`, `Light`, `Dark`, etc.)
  - Cada mode ter√° seus pr√≥prios valores na respectiva coluna
- **Extrair nome da cole√ß√£o**: O nome da tabela √© o nome da cole√ß√£o
- **Extrair nomes dos modes**: As colunas ap√≥s `Token Name` s√£o os nomes dos modes
- **Processamento de m√∫ltiplos modes**:
  - Se houver apenas uma coluna de mode (ex: apenas `Value`), criar um √∫nico arquivo JSON
  - Se houver m√∫ltiplas colunas de modes (ex: `Light`, `Dark`, `Value`), criar um arquivo JSON separado para cada mode
  - Cada arquivo ser√° nomeado como `{nome-do-mode}.json` dentro da pasta da cole√ß√£o
- Verificar se a pasta j√° existe; se n√£o, criar
- **VALIDA√á√ÉO IMPORTANTE**: Para cada mode detectado, verificar se j√° existe um arquivo com esse nome na pasta da cole√ß√£o
  - Se existir, apresentar op√ß√µes:
    - ‚úÖ **Mesclar com arquivo existente** (adicionar/atualizar tokens)
    - ‚úÖ **Sobrescrever** o arquivo existente (apagar tudo e criar novo)
    - ‚úÖ **Criar com outro nome** (sugerir ou solicitar novo nome)
    - ‚úÖ **Cancelar** a opera√ß√£o
  - Aguardar escolha do usu√°rio antes de prosseguir

#### IMPORTANTE: Leitura de Tabelas do Coda

**ATEN√á√ÉO**: Se a URL fornecida for do Coda (coda.io), **N√ÉO tente fazer scraping** da p√°gina web, pois o Coda usa virtual scrolling e n√£o renderiza todas as linhas visualmente.

**Solu√ß√£o obrigat√≥ria**: Usar o **MCP do Coda** para obter todos os dados.

**Fluxo para tabelas do Coda:**

1. **Identificar URL do Coda**: 
   - Formato t√≠pico: `https://coda.io/d/DOC_ID/TABLE_NAME`

2. **Usar MCP do Coda**:
   - O ambiente j√° possui MCP do Coda configurado
   - N√£o √© necess√°rio solicitar API Token
   - Usar as ferramentas dispon√≠veis do MCP para acessar o documento

3. **Extrair informa√ß√µes da URL**:
   - Doc ID
   - Table/View ID (pode precisar solicitar ao usu√°rio se n√£o estiver claro na URL)

4. **Acessar dados via MCP**:
   - Utilizar as ferramentas do MCP do Coda para listar e ler as linhas da tabela
   - O MCP retorna todos os registros (sem limita√ß√£o de virtual scrolling)
   - Iterar por todas as p√°ginas se houver pagina√ß√£o
   - **Extrair nome da cole√ß√£o**: O nome da tabela √© o nome da cole√ß√£o
   - **Extrair nomes dos modes**: Identificar todas as colunas ap√≥s `Token Name` (ou `Token name`) - estas s√£o os nomes dos modes
   - Extrair coluna `Token Name` e todas as colunas de modes

**Tratamento de pagina√ß√£o**:
Se houver muitos dados, processar em lotes e informar o progresso:
```
üìä Carregando tokens do Coda via MCP...
- Processando: 100 tokens
- Processando: 200 tokens
- Processando: 247 tokens
‚úÖ Total: 247 tokens carregados
```

**Tratamento de erros**:
- Se o MCP n√£o conseguir acessar o documento, informar o usu√°rio
- Se a tabela n√£o for encontrada, listar as tabelas dispon√≠veis no documento
- Se a coluna `Token Name` (ou `Token name`) n√£o existir, solicitar o nome correto da coluna
- Se n√£o houver colunas de modes (apenas `Token Name`), informar que √© necess√°rio pelo menos uma coluna de mode
- Se n√£o for poss√≠vel extrair o nome da cole√ß√£o do nome da tabela, solicitar ao usu√°rio
- Se n√£o for poss√≠vel identificar as colunas de modes, listar as colunas encontradas e solicitar confirma√ß√£o

#### Outras Fontes de Dados

Para tabelas em outras plataformas (Google Sheets, Notion, Excel Online, etc.), verificar se existem MCPs ou APIs dispon√≠veis e instruir o usu√°rio adequadamente. Caso n√£o haja integra√ß√£o dispon√≠vel, solicitar que o usu√°rio exporte os dados ou forne√ßa acesso adequado.

### 2. Perguntar ColorSpace (para cores)
- Solicitar qual colorSpace ser√° usado para convers√£o de cores
- Op√ß√µes dispon√≠veis em: https://www.designtokens.org/tr/2025.10/color
- Exemplos: `srgb`, `oklch`, `hsl`, etc.

### 3. Perguntar Base de Convers√£o (para n√∫meros)
- Solicitar a base de convers√£o para rem/em ‚Üí px
- Sugest√£o padr√£o: **16px**

### 4. Processar Tabela e Gerar JSON
- Ler a tabela da URL fornecida
- **Extrair nome da cole√ß√£o** do nome da tabela
- **Identificar colunas de modes**: Todas as colunas ap√≥s `Token Name` s√£o modes
- **Para cada mode detectado**:
  - Criar um arquivo JSON separado: `{nome-do-mode}.json`
  - Processar todos os tokens da coluna desse mode
  - **Normalizar tokens alpha** (ex: `jf.color.alpha.white.100` ‚Üí `jf.color.white.100`)
  - **Ignorar tokens com valor "composition" ou "composi√ß√£o"** (n√£o processar estes tokens)
  - **Detectar tokens com variantes** (verificar se existem tokens que come√ßam com o nome base + ".")
  - **Processar tokens base primeiro** (criar estrutura com `$root` se necess√°rio)
  - **Processar variantes depois** (adicionar ao objeto base existente)
  - Analisar cada token e aplicar as regras de convers√£o
  - Gerar o arquivo JSON no formato DTCG compat√≠vel com Figma
  - Incluir o metadado `com.figma.modeName` com o nome do mode
- **Se houver apenas um mode**: Criar um √∫nico arquivo JSON
- **Se houver m√∫ltiplos modes**: Criar m√∫ltiplos arquivos JSON, um para cada mode

### 4.1. Processamento de M√∫ltiplos Modes

Quando a tabela cont√©m m√∫ltiplas colunas de modes, a IA deve:

1. **Identificar todas as colunas de modes**:
   - Primeira coluna: `Token Name` (ou `Token name`)
   - Colunas seguintes: Nomes dos modes (ex: `Value`, `Light`, `Dark`, `Mobile`, `Desktop`, etc.)

2. **Processar cada mode independentemente**:
   - Para cada coluna de mode, criar um arquivo JSON separado
   - Cada arquivo conter√° apenas os tokens daquele mode espec√≠fico
   - O nome do arquivo ser√° `{nome-do-mode}.json` (case-sensitive)

3. **Estrutura de arquivos gerados**:
   ```
   packages/tokens/src/figma/
     ‚îî‚îÄ‚îÄ {nome-da-colecao}/
         ‚îú‚îÄ‚îÄ {mode-1}.json
         ‚îú‚îÄ‚îÄ {mode-2}.json
         ‚îî‚îÄ‚îÄ {mode-3}.json
   ```

4. **Exemplo de tabela com m√∫ltiplos modes**:
   | Token name | Light | Dark | Value |
   |------------|-------|------|-------|
   | jf.color.white | #ffffff | #000000 | #ffffff |
   | jf.color.black | #000000 | #ffffff | #000000 |

   **Resultado**: Ser√£o criados 3 arquivos:
   - `Light.json` com tokens da coluna Light
   - `Dark.json` com tokens da coluna Dark
   - `Value.json` com tokens da coluna Value

5. **Valida√ß√£o de arquivos existentes**:
   - Para cada mode, verificar se o arquivo j√° existe
   - Se existir, seguir o fluxo de valida√ß√£o (mesclar/sobrescrever/cancelar)
   - Aplicar a mesma a√ß√£o escolhida para todos os modes ou permitir escolha individual

6. **Tratamento de valores vazios**:
   - Se um token tiver valor vazio em um mode espec√≠fico, esse token n√£o ser√° inclu√≠do no JSON daquele mode
   - Tokens com valores vazios em todos os modes ser√£o ignorados completamente
   - Informar ao usu√°rio quais tokens foram pulados por mode (opcional, apenas se houver muitos)

7. **Mensagem ao usu√°rio**:
   ```
   üìä Processando tabela "Primitives"...
   
   ‚úÖ Cole√ß√£o detectada: Primitives
   ‚úÖ Modes detectados: Light, Dark, Value
   
   üìÅ Arquivos a serem criados:
   - packages/tokens/src/figma/Primitives/Light.json
   - packages/tokens/src/figma/Primitives/Dark.json
   - packages/tokens/src/figma/Primitives/Value.json
   
   ‚ö†Ô∏è Verificando arquivos existentes...
   ```

---

## Regras de Nomenclatura

### Conven√ß√µes Suportadas
Os tokens podem usar duas conven√ß√µes de nomenclatura:

1. **Dot notation**: `jf.color.white`
2. **Slash notation**: `jf/color/white`

Ambas resultam na mesma estrutura JSON aninhada.

### Ignorar Tokens de Composi√ß√£o

**IMPORTANTE**: Tokens com valor `"composition"` ou `"composi√ß√£o"` devem ser **ignorados** e n√£o processados:

- Se o valor do token for exatamente `"composition"` ou `"composi√ß√£o"` (case-insensitive), o token n√£o deve ser inclu√≠do no JSON final
- Estes tokens s√£o marcadores de composi√ß√£o e n√£o representam valores de design tokens
- N√£o gerar erro ou aviso, apenas ignorar silenciosamente

**Exemplo**:
```
Token name: jf.color.composition
Value: composition

A√ß√£o: Token ignorado, n√£o inclu√≠do no JSON
```

### Normaliza√ß√£o de Tokens Alpha

**IMPORTANTE**: Tokens com estrutura `alpha` devem ser normalizados antes do processamento:

- `jf.color.alpha.white.100` ‚Üí `jf.color.white.100`
- `jf.color.alpha.black.200` ‚Üí `jf.color.black.200`

**Regra de normaliza√ß√£o**:
1. Identificar tokens que cont√™m `alpha.` no nome
2. Extrair o nome da cor (ex: `white`, `black`) que vem ap√≥s `alpha.`
3. Extrair a variante num√©rica (ex: `100`, `200`) que vem no final
4. Reconstruir o nome como: `jf.color.{cor}.{variante}`

**Exemplo**:
```
Token original: jf.color.alpha.white.100
Token normalizado: jf.color.white.100
Base do token: jf.color.white
```

### Regra do `$root`

**Detec√ß√£o de variantes**:
- Um token tem variantes se existem outros tokens que come√ßam com o nome do token base seguido de `.` e um sufixo
- Exemplo: `jf.color.white` tem variantes se existir `jf.color.white.100`, `jf.color.white.200`, etc.

**Regras de aplica√ß√£o**:
- **SEM variantes**: Se existir apenas `jf.color.white` (sem sufixos num√©ricos como 100, 200), o valor fica diretamente em `"white"`
- **COM variantes**: Se existir `jf.color.white` E `jf.color.white.100` (ou outras variantes), usar `"$root"` para o valor base

**Ordem de processamento cr√≠tica**:
1. **Primeiro**: Processar todos os tokens base (sem sufixos num√©ricos)
2. **Depois**: Processar todas as variantes (com sufixos num√©ricos)
3. Isso garante que o objeto base seja criado com `$root` antes de adicionar variantes

**Exemplo SEM variantes:**
```json
{
  "jf": {
    "color": {
      "white": {
        "$type": "color",
        "$value": {...}
      }
    }
  }
}
```

**Exemplo COM variantes:**
```json
{
  "jf": {
    "color": {
      "white": {
        "$root": {
          "$type": "color",
          "$value": {...}
        },
        "100": {
          "$type": "color",
          "$value": {...}
        }
      }
    }
  }
}
```

---

## Regras de Convers√£o por Tipo

### 1. CORES (`$type: "color"`)

**Identifica√ß√£o**: Tokens que cont√™m "color" no nome ou valores em formatos de cor (hex, rgb, hsl, oklch, etc.)

**Formato de Sa√≠da**:
```json
{
  "$type": "color",
  "$value": {
    "colorSpace": "oklch",
    "components": [1, 0, 0],
    "alpha": 1,
    "hex": "#ffffff"
  }
}
```

**Regras de Convers√£o**:
1. Converter qualquer formato de cor para o padr√£o DTCG usando o colorSpace informado pelo usu√°rio
2. Sempre incluir o metadado `"hex"` com o valor em hexadecimal
3. Se a cor possuir opacidade:
   - Converter para escala 0-1
   - Inserir no metadado `"alpha"`
   - Exemplo: `10%` ‚Üí `0.1`

**Exemplos**:

| Token name | Value |
|------------|-------|
| `jf.color.alpha.white.100` | `oklch(1 0 0 / 10%)` |
| `jf.color.white` | `#ffffff` |

**Nota**: O token `jf.color.alpha.white.100` √© normalizado para `jf.color.white.100` antes do processamento.

ColorSpace: `oklch`

Resultado:
```json
{
  "jf": {
    "color": {
      "white": {
        "$root": {
          "$type": "color",
          "$value": {
            "colorSpace": "oklch",
            "components": [1, 0, 0],
            "alpha": 1,
            "hex": "#ffffff"
          }
        },
        "100": {
          "$type": "color",
          "$value": {
            "colorSpace": "oklch",
            "components": [1, 0, 0],
            "alpha": 0.1,
            "hex": "#ffffff"
          }
        }
      }
    }
  }
}
```

---

### 2. N√öMEROS (`$type: "number"`)

**Identifica√ß√£o**: Tokens que cont√™m no nome:
- `scale`
- `opacity`
- `border-width`
- `corner`
- `line-height`
- `letter-spacing`
- `font-size`
- `duration`
- `blur`
- `angle`
- `cols`
- `layer`
- `width`
- `height`
- `gap`
- `padding`
- `margin`

**Formato de Sa√≠da**:
```json
{
  "$type": "number",
  "$value": 16
}
```

**Regras de Convers√£o**:
1. Figma trabalha apenas com **px** (sem unidade no valor final)
2. Convers√µes necess√°rias:
   - `rem` ‚Üí multiplicar pela base de convers√£o (ex: 16px)
   - `em` ‚Üí multiplicar pela base de convers√£o (ex: 16px)
   - `px` ‚Üí manter apenas o valor num√©rico
   - `%` ‚Üí dividir por 100 (ex: `50%` = `0.5`)
   - `ms` (duration) ‚Üí remover sufixo e manter n√∫mero (ex: `300ms` = `300`)

**Exemplos**:

| Token name | Value |
|------------|-------|
| `jf.letter-spacing.compact` | `-0.05em` |

Base de convers√£o: 16px

Resultado:
```json
{
  "jf": {
    "letter-spacing": {
      "compact": {
        "$type": "number",
        "$value": -0.8
      }
    }
  }
}
```

| Token name | Value |
|------------|-------|
| `jf.scale.8` | `1rem` |

Resultado:
```json
{
  "jf": {
    "scale": {
      "8": {
        "$type": "number",
        "$value": 16
      }
    }
  }
}
```

---

### 3. STRINGS (`$type: "string"`)

**Identifica√ß√£o**: Tokens que cont√™m no nome:
- `font-family`
- `font-weight`
- `ratio`

**Formato de Sa√≠da**:
```json
{
  "$type": "string",
  "$value": "Thin"
}
```

**Regras de Convers√£o**:

#### font-weight
- Se o valor for **num√©rico**, converter para nome com **primeira letra mai√∫scula**:
  - `100` ‚Üí `"Thin"`
  - `200` ‚Üí `"Extra Light"`
  - `300` ‚Üí `"Light"`
  - `400` ‚Üí `"Regular"`
  - `500` ‚Üí `"Medium"`
  - `600` ‚Üí `"Semi Bold"`
  - `700` ‚Üí `"Bold"`
  - `800` ‚Üí `"Extra Bold"`
  - `900` ‚Üí `"Black"`
- Se o valor for **texto**, manter exatamente como est√° (ex: `"bold"` fica `"bold"`)

#### font-family e ratio
- Manter o valor original da tabela

**Exemplo**:

| Token name | Value |
|------------|-------|
| `jf.font-weight.100` | `100` |

Resultado:
```json
{
  "jf": {
    "font-weight": {
      "100": {
        "$type": "string",
        "$value": "Thin"
      }
    }
  }
}
```

---

## Formato Final do JSON

O arquivo JSON deve seguir o padr√£o DTCG (Design Tokens Community Group) compat√≠vel com Figma:

```json
{
  "namespace": {
    "category": {
      "token-name": {
        "$type": "color|number|string",
        "$value": {...}
      }
    }
  },
  "$extensions": {
    "com.figma.modeName": "Mode 1"
  }
}
```

### Metadados Obrigat√≥rios do Figma

**IMPORTANTE**: Todo arquivo JSON deve incluir a extens√£o `com.figma.modeName` antes de fechar a raiz do objeto.

O valor de `"com.figma.modeName"` deve ser **exatamente o nome do mode** extra√≠do do nome da coluna correspondente na tabela.

**Exemplo completo:**

Se a tabela cont√©m uma coluna de mode chamada "Light", o JSON final para `Light.json` deve ser:

```json
{
  "jf": {
    "color": {
      "white": {
        "$type": "color",
        "$value": {
          "colorSpace": "srgb",
          "components": [1, 1, 1],
          "alpha": 1,
          "hex": "#ffffff"
        }
      },
      "black": {
        "$type": "color",
        "$value": {
          "colorSpace": "srgb",
          "components": [0, 0, 0],
          "alpha": 1,
          "hex": "#000000"
        }
      }
    },
    "spacing": {
      "small": {
        "$type": "number",
        "$value": 8
      }
    }
  },
  "$extensions": {
    "com.figma.modeName": "light"
  }
}
```

**Regras para `$extensions`:**
1. Deve ser sempre o **√∫ltimo elemento** do JSON (antes de fechar `}`)
2. O valor de `"com.figma.modeName"` √© uma **string** com o nome do mode extra√≠do do nome da coluna correspondente
3. Use exatamente o nome da coluna (case-sensitive)
4. **Obrigat√≥rio em todos os arquivos** de design tokens
5. **Cada arquivo JSON ter√° seu pr√≥prio `modeName`** correspondente ao nome da coluna de mode que originou os tokens

---

## Valida√ß√µes Importantes

1. **Verificar se a pasta `figma` existe**, se n√£o, criar
2. **Extrair nome da cole√ß√£o** do nome da tabela
3. **Identificar todas as colunas de modes** (colunas ap√≥s `Token Name`)
4. **Verificar se a pasta da cole√ß√£o existe**, se n√£o, criar
5. **Para cada mode detectado**: Verificar se o arquivo do mode j√° existe, se sim, perguntar a√ß√£o ao usu√°rio
6. **Validar URL da tabela** antes de processar
7. **Validar estrutura da tabela**: Deve ter coluna `Token Name` e pelo menos uma coluna de mode
8. **Ignorar tokens com valor "composition" ou "composi√ß√£o"** (n√£o processar)
9. **Normalizar tokens alpha** antes do processamento
10. **Detectar tokens com variantes** corretamente
11. **Processar tokens base antes das variantes** para garantir estrutura correta
12. **Detectar automaticamente o tipo de token** baseado no nome
13. **Aplicar convers√µes corretas** baseadas no tipo identificado
14. **Criar arquivo JSON separado para cada mode** quando houver m√∫ltiplos modes

---

## Tratamento de Valores Din√¢micos (clamp, calc, var, etc.)

Quando a IA detectar valores din√¢micos que o Figma n√£o suporta diretamente (como `clamp()`, `calc()`, `var()`, etc.), deve seguir este fluxo:

### 1. Detectar e Informar
```
üîç Detectei valor din√¢mico: clamp(1.1375rem, 1.1073rem + 0.3523vw, 1.5rem)

‚ö†Ô∏è O Figma n√£o suporta valores din√¢micos como clamp(). 
Preciso criar valores fixos para diferentes breakpoints/plataformas.

Convertendo para px (base: 16px):
- M√≠nimo: 1.1375rem ‚Üí 18.2px
- M√°ximo: 1.5rem ‚Üí 24px
```

### 2. Perguntar sobre a Cole√ß√£o
```
Deseja:
A) Criar uma NOVA cole√ß√£o multi-plataforma
B) Usar uma cole√ß√£o multi-plataforma EXISTENTE
C) Definir um valor fixo √∫nico (n√£o recomendado)
D) Pular este token

Escolha: _
```

### 3A. Se Escolher "Nova Cole√ß√£o"
```
üìÅ Nome da nova cole√ß√£o multi-plataforma: _
(ex: responsive-tokens, breakpoints, etc.)
```

### 3B. Se Escolher "Cole√ß√£o Existente"
```
üìÅ Cole√ß√µes dispon√≠veis em packages/tokens/src/figma/:
- design-system
- brand
- responsive-tokens

Qual cole√ß√£o usar? _
```

### 4. Perguntar Quantidade de Modos
```
üì± Quantos modos/breakpoints deseja criar?
Sugest√£o: 2 (um para valor m√≠nimo, outro para valor m√°ximo)

Digite o n√∫mero: _
```

### 5. Solicitar Nome de Cada Modo
```
Nome do modo 1: _ (sugest√£o: mobile)
Nome do modo 2: _ (sugest√£o: desktop)
Nome do modo 3: _ (se aplic√°vel)
...
```

### 6. Solicitar Valores para Cada Modo
Para cada token com valor din√¢mico, perguntar o valor em cada modo:

```
Valores para o token "jf.font-size.xl":

üîπ Modo "mobile":
- Valor: _ (sugest√£o: 18.2)

üîπ Modo "desktop":
- Valor: _ (sugest√£o: 24)
```

**IMPORTANTE**: 
- Todos os valores devem ser convertidos para px (se estiverem em rem/em)
- Tokens criados ser√£o do tipo `number` (sem unidade)
- Aplicar todas as regras de convers√£o de n√∫meros

### 7. Confirmar Antes de Criar
```
‚úÖ Resumo:
Cole√ß√£o: responsive-tokens
Modos: mobile.json, desktop.json

Tokens a serem criados:

mobile.json:
- jf.font-size.xl = 18.2 (number)
- jf.padding.large = 16 (number)

desktop.json:
- jf.font-size.xl = 24 (number)
- jf.padding.large = 24 (number)

Confirmar cria√ß√£o? (s/n)
```

### 8. Criar Arquivos
Criar um arquivo `.json` para cada modo dentro da cole√ß√£o especificada:
```
packages/tokens/src/figma/
  ‚îî‚îÄ‚îÄ responsive-tokens/
      ‚îú‚îÄ‚îÄ mobile.json
      ‚îî‚îÄ‚îÄ desktop.json
```

### Exemplo de Sa√≠da

**mobile.json:**
```json
{
  "jf": {
    "font-size": {
      "xl": {
        "$type": "number",
        "$value": 18.2
      }
    }
  }
}
```

**desktop.json:**
```json
{
  "jf": {
    "font-size": {
      "xl": {
        "$type": "number",
        "$value": 24
      }
    }
  }
}
```

---

## Valida√ß√£o e Atualiza√ß√£o de Arquivos Existentes

### Regra Cr√≠tica: NUNCA Resetar JSON Existente

Quando trabalhar com arquivos `.json` que j√° existem, a IA deve **SEMPRE**:

1. **Ler o conte√∫do atual** do arquivo antes de qualquer modifica√ß√£o
2. **Preservar todos os tokens existentes** que n√£o est√£o sendo alterados
3. **Validar cada token** antes de adicionar ou modificar

### Fluxo de Valida√ß√£o para Tokens

#### Ao Adicionar/Atualizar Tokens em Arquivo Existente:

**Passo 1**: Ler arquivo JSON atual e identificar tokens existentes

**Passo 2**: Para cada token na nova tabela, verificar:

```
üîç Analisando token: jf.color.primary

Status: ‚úÖ Novo token (n√£o existe no arquivo)
A√ß√£o: Ser√° adicionado ao JSON

---

üîç Analisando token: jf.color.white

Status: ‚ö†Ô∏è Token j√° existe no arquivo
Valor atual: #ffffff
Novo valor: #f5f5f5

Deseja sobrescrever este token?
A) Sim, atualizar para o novo valor
B) N√£o, manter o valor atual
C) Cancelar opera√ß√£o

Escolha: _
```

**Passo 3**: Mostrar resumo antes de salvar

```
üìã Resumo das altera√ß√µes em "light.json":

‚úÖ TOKENS NOVOS (ser√£o adicionados):
- jf.color.primary = #0066cc
- jf.spacing.large = 24

‚ö†Ô∏è TOKENS ATUALIZADOS (valores alterados):
- jf.color.white: #ffffff ‚Üí #f5f5f5

üîí TOKENS PRESERVADOS (sem altera√ß√µes):
- jf.color.black = #000000
- jf.font-size.base = 16
... (+ 15 outros tokens)

Confirmar altera√ß√µes? (s/n)
```

**Passo 4**: Aplicar mudan√ßas apenas se confirmado

### Estrutura de Mesclagem

Ao mesclar tokens novos com arquivo existente:

**Antes (arquivo existente):**
```json
{
  "jf": {
    "color": {
      "black": {
        "$type": "color",
        "$value": {...}
      }
    }
  }
}
```

**Depois (com tokens novos mesclados):**
```json
{
  "jf": {
    "color": {
      "black": {
        "$type": "color",
        "$value": {...}
      },
      "white": {
        "$type": "color",
        "$value": {...}
      },
      "primary": {
        "$type": "color",
        "$value": {...}
      }
    }
  }
}
```

### Avisos Importantes ao Usu√°rio

Sempre que tokens forem adicionados a um arquivo existente, exibir:

```
‚úÖ Arquivo "light.json" atualizado com sucesso!

üìä Estat√≠sticas:
- 2 tokens novos adicionados
- 1 token atualizado
- 15 tokens preservados
- Total: 18 tokens no arquivo

‚ö†Ô∏è IMPORTANTE: O arquivo foi mesclado, n√£o sobrescrito.
Todos os tokens anteriores foram preservados.
```

### Casos Especiais

#### Caso 1: Conflito de Estrutura
Se um token existente tiver estrutura diferente (ex: era simples, agora tem variantes):

```
‚ö†Ô∏è CONFLITO DETECTADO

Token "jf.color.white" existe como:
{
  "white": {
    "$type": "color",
    "$value": {...}
  }
}

Mas voc√™ est√° tentando adicionar variantes:
{
  "white": {
    "$root": {...},
    "100": {...}
  }
}

Isso requer reestrutura√ß√£o. Deseja:
A) Converter para estrutura com variantes (recomendado)
B) Manter estrutura atual e ignorar variantes
C) Cancelar opera√ß√£o

Escolha: _
```

#### Caso 2: Remo√ß√£o de Tokens
Se o usu√°rio quiser remover tokens:

```
üóëÔ∏è Remo√ß√£o de tokens

Esta opera√ß√£o √© permanente. Confirme os tokens a remover:
- jf.color.deprecated
- jf.spacing.old

Confirmar remo√ß√£o? (s/n)
```

---

## Tratamento de Erros

1. Se a URL da tabela n√£o for acess√≠vel, informar ao usu√°rio
2. Se a estrutura da tabela for inv√°lida:
   - Verificar se existe coluna `Token Name` (ou `Token name`)
   - Verificar se existe pelo menos uma coluna de mode ap√≥s `Token Name`
   - Se n√£o houver colunas de modes, informar e solicitar estrutura correta
3. Se houver valores que n√£o podem ser convertidos, registrar e informar quais tokens falharam (por mode)
4. Se valores din√¢micos forem detectados, seguir o fluxo de cole√ß√£o multi-plataforma
5. **Se arquivo existir, NUNCA sobrescrever sem permiss√£o expl√≠cita** (aplicar para cada arquivo de mode)
6. **Se token existente for modificado, SEMPRE pedir confirma√ß√£o** (aplicar para cada arquivo de mode)
7. **Se houver conflito de estrutura, SEMPRE alertar e pedir decis√£o** (aplicar para cada arquivo de mode)
8. Sempre criar o JSON mesmo com erros parciais, mas avisar sobre os tokens problem√°ticos
9. Se houver m√∫ltiplos modes e algum mode falhar, processar os outros modes e informar quais falharam
10. Se um token tiver valor vazio em um mode espec√≠fico, pular esse token apenas para aquele mode (n√£o criar entrada no JSON)

---

## Mensagens ao Usu√°rio

Mantenha uma comunica√ß√£o clara e profissional:
- Confirme cada etapa antes de prosseguir
- Informe sobre valida√ß√µes e convers√µes realizadas
- **Quando houver m√∫ltiplos modes**: Mostrar resumo de todos os modes detectados e arquivos que ser√£o criados
- Mostre preview do JSON antes de salvar (opcional, pode ser por mode)
- Confirme sucesso na cria√ß√£o dos arquivos com os caminhos completos
- **Exemplo de mensagem para m√∫ltiplos modes**:
  ```
  ‚úÖ Processamento conclu√≠do!
  
  üìÅ Arquivos criados:
  - packages/tokens/src/figma/Primitives/Light.json (45 tokens)
  - packages/tokens/src/figma/Primitives/Dark.json (45 tokens)
  - packages/tokens/src/figma/Primitives/Value.json (45 tokens)
  
  üìä Estat√≠sticas:
  - Total de tokens processados: 45
  - Tokens de cor: 20
  - Tokens num√©ricos: 15
  - Tokens de string: 10
  ```

